name: Update Fiscal Data

on:
  schedule:
    - cron: '0 8 * * 1'  # Monday 8:00 UTC
  workflow_dispatch:

permissions:
  contents: write
  issues: write

jobs:
  update:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
      - run: npm ci
      - run: npm run download-data
      - uses: stefanzweifel/git-auto-commit-action@v5
        if: success()
        with:
          commit_message: "chore: update fiscal data"
          file_pattern: src/data/*.json public/api/v1/*.json public/api/openapi.json public/seo-snapshot.html public/sitemap.xml public/feed.xml public/secciones/*.html public/en/sections/*.html

      - name: Check for stale data
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = 'src/data/meta.json';
            if (!fs.existsSync(path)) {
              console.log('No meta.json found, skipping stale check.');
              return;
            }
            
            const meta = JSON.parse(fs.readFileSync(path, 'utf8'));
            const now = new Date();
            const staleThresholdDays = 14;
            const staleSources = [];
            let ssCriticalFallback = null;

            for (const [name, info] of Object.entries(meta.sources)) {
              if (!info.success) {
                staleSources.push(`**${name}**: FallÃ³ en la Ãºltima descarga.`);
                continue;
              }
              if (name === 'pensions' && info.criticalFallback) {
                ssCriticalFallback = info.criticalFallbackReason || 'No se pudo descargar ningÃºn REG*.xlsx y se usÃ³ fallback.';
                staleSources.push(`**${name}**: FALLBACK CRÃTICO (${ssCriticalFallback})`);
                continue;
              }
              const freshnessDate = info.lastRealDataDate || info.lastUpdated;
              if (!freshnessDate) {
                staleSources.push(`**${name}**: Sin fecha de Ãºltima actualizaciÃ³n.`);
                continue;
              }
              const lastUpdated = new Date(freshnessDate);
              const diffDays = (now - lastUpdated) / (1000 * 60 * 60 * 24);
              if (diffDays > staleThresholdDays) {
                staleSources.push(`**${name}**: No se actualiza desde hace ${diffDays.toFixed(1)} dÃ­as (lÃ­mite: ${staleThresholdDays} dÃ­as).`);
              }
            }

            if (staleSources.length > 0) {
              console.log('Stale sources detected:', staleSources);
              
              // Check if there is already an open issue for stale data to avoid duplicates
              const issues = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                labels: 'data-stale'
              });
              
              if (issues.data.length > 0) {
                console.log('An open issue for stale data already exists. Updating it...');
                const issueNumber = issues.data[0].number;
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  body: `La alerta persiste. Estado actual:\n\n- ${staleSources.join('\n- ')}`
                });
              } else {
                console.log('Creating new issue for stale data...');
                await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: 'âš ï¸ Alerta: Datos desactualizados en Dashboard Fiscal',
                  body: `Las siguientes fuentes de datos estÃ¡n desactualizadas o fallando:\n\n- ${staleSources.join('\n- ')}\n\nPor favor, revisa los logs del workflow y las fuentes oficiales.`,
                  labels: ['data-stale', 'bug']
                });
              }
            } else {
              console.log('All data sources are fresh.');
            }

            // Dedicated alert for Seguridad Social critical fallback
            const ssIssues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'ss-fallback'
            });

            if (ssCriticalFallback) {
              const body = `El scraper de pensiones no pudo procesar ningÃºn REG*.xlsx y el pipeline cayÃ³ en fallback.\n\nMotivo: ${ssCriticalFallback}\n\nRevisar logs del workflow y enlaces actuales de EST24/REG*.xlsx.`;
              if (ssIssues.data.length > 0) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: ssIssues.data[0].number,
                  body: `La alerta de fallback crÃ­tico en Seguridad Social persiste.\n\n${body}`
                });
              } else {
                await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: 'ðŸš¨ Alerta: fallback crÃ­tico en pensiones (Seguridad Social)',
                  body,
                  labels: ['ss-fallback', 'bug', 'data-stale']
                });
              }
            } else if (ssIssues.data.length > 0) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: ssIssues.data[0].number,
                body: 'âœ… Recuperado: el Ãºltimo run volviÃ³ a usar datos en vivo de Seguridad Social. Se cierra la alerta.'
              });
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: ssIssues.data[0].number,
                state: 'closed'
              });
            }
